//
//  DraftInactiveVC.m
//  emSigner
//
//  Created by Administrator on 12/29/16.
//  Copyright © 2016 Emudhra. All rights reserved.
//

#import "DraftInactiveVC.h"
#import "WebserviceManager.h"
#import "HoursConstants.h"
#import "MBProgressHUD.h"
#import "NSObject+Activity.h"
#import "LMNavigationController.h"
#import "CoSignPendingVC.h"
#import "ShareVC.h"

#include "mupdf/common.h"
#import "mupdf/MuPageViewNormal.h"
#import "mupdf/MuPageViewReflow.h"
#import "mupdf/MuTextFieldController.h"
#import "mupdf/MuChoiceFieldController.h"
#import "mupdf/MuPrintPageRenderer.h"

#define GAP 5
#define INDICATOR_Y -44-24
#define SLIDER_W (width - GAP - 24)
#define SEARCH_W (width - GAP - 170)
#define MIN_SCALE (1.0)
#define MAX_SCALE (5.0)

@interface DraftInactiveVC ()

@end

@implementation DraftInactiveVC
enum
{
    ResourceCacheMaxSize = 128<<20	/**< use at most 128M for resource cache */
};
fz_document *doc;
MuDocRef *docRef;
NSString *key;
NSString *_filePath;
BOOL reflowMode;
UIScrollView *canvasScrollView;
UIBarButtonItem *backButton;
int barmode;
int searchPage;
int cancelSearch;
int showLinks;
int width; // current screen size
int height;
int current; // currently visible page
int scroll_animating; // stop view updates during scrolling animations
float scale; // scale applied to views (only used in reflow mode)
BOOL _isRotating;
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view from its nib.
    
    //
    UIView *view = [[UIView alloc] initWithFrame: CGRectZero];
    view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    [view setAutoresizesSubviews: YES];
    view.backgroundColor = [UIColor grayColor];
    
    
    canvasScrollView = [[UIScrollView alloc] initWithFrame: CGRectMake(0,0,self.pdfView.bounds.size.width, self.pdfView.bounds.size.height)];
    canvasScrollView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    [canvasScrollView setPagingEnabled: YES];
    [canvasScrollView setShowsHorizontalScrollIndicator: NO];
    [canvasScrollView setShowsVerticalScrollIndicator: NO];
    canvasScrollView.delegate = self;
    [self.pdfView addSubview: canvasScrollView];
    //

    
}

-(void)viewWillAppear:(BOOL)animated
{
    current=0;
//    NSData *data = [[NSData alloc]initWithBase64EncodedString:_pdfImagedetail options:0];
//    
//    _webView.scalesPageToFit = YES;
//    _webView.opaque = NO;
//    _webView.backgroundColor = [UIColor clearColor];
//    [_webView loadData:data MIMEType:@"application/pdf" textEncodingName:@"utf-8" baseURL:[NSURL URLWithString:@"http://"]];
//    //
    self.title = _myTitle;
    [self.navigationController.navigationBar setTitleTextAttributes:
     @{NSForegroundColorAttributeName:[UIColor whiteColor]}];
}

- (instancetype) initWithFilename: (NSString*)filename path:(NSString *)cstr document: (MuDocRef *)aDoc
{
    self = [super initWithNibName:nil bundle:nil];
    if (!self)
        return nil;
    
#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000
    if ([self respondsToSelector:@selector(automaticallyAdjustsScrollViewInsets)])
        self.automaticallyAdjustsScrollViewInsets = NO;
#endif
    // key = [filename copy];
    docRef = aDoc;
    doc = docRef->doc;
    _filePath = [cstr copy];
    
    //  this will be created right before the outline is shown
    //outline = nil;
    
    dispatch_sync(queue, ^{});
    
    return self;
}

- (void) viewWillLayoutSubviews
{
    CGSize size = canvasScrollView.frame.size;
    // int max_width = fz_max(width, size.width);
    
    width = size.width;
    height = size.height;
    
    canvasScrollView
    .contentInset = UIEdgeInsetsZero;
    canvasScrollView.contentSize = CGSizeMake(fz_count_pages(ctx, doc) * width, height);
    canvasScrollView.contentOffset = CGPointMake(current * width, 0);
    
    // use max_width so we don't clamp the content offset too early during animation
    //    canvasScrollView.contentSize = CGSizeMake(fz_count_pages(ctx, doc) * max_width, height);
    //    canvasScrollView.contentOffset = CGPointMake(current * width, 0);
    
    for (UIView<MuPageView> *view in canvasScrollView.subviews) {
        if (view.number == current) {
            view.frame = CGRectMake(view.number * width, 0, width-GAP, height);
            [view willRotate];
        }
    }
    for (UIView<MuPageView> *view in canvasScrollView.subviews) {
        if (view.number != current) {
            view.frame = CGRectMake(view.number * width, 0, width-GAP, height);
            [view willRotate];
        }
    }
}

//    CGSize size = _canvasScrollView.frame.size;
//    int max_width = fz_max(height, size.height);
//
//    width = size.width+50;
//    height = size.height;
//
//    _canvasScrollView.contentInset = UIEdgeInsetsZero;
//    _canvasScrollView.contentSize = CGSizeMake(width, fz_count_pages(ctx, doc) *height);
//    _canvasScrollView.contentOffset = CGPointMake(0, current * height);
//
//    // use max_width so we don't clamp the content offset too early during animation
//    _canvasScrollView.contentSize = CGSizeMake(width, fz_count_pages(ctx, doc) * max_width);
//    _canvasScrollView.contentOffset = CGPointMake(0,current * height);
//}

- (void) viewDidAppear: (BOOL)animated
{
    [super viewDidAppear:animated];
    [self scrollViewDidScroll: canvasScrollView];
}
- (void) gotoPage: (int)number animated: (BOOL)animated
{
    if (number < 0)
        number = 0;
    if (number >= fz_count_pages(ctx, doc))
        number = fz_count_pages(ctx, doc) - 1;
    if (current == number)
        return;
    if (animated) {
        // setContentOffset:animated: does not use the normal animation
        // framework. It also doesn't play nice with the tap gesture
        // recognizer. So we do our own page flipping animation here.
        // We must set the scroll_animating flag so that we don't create
        // or remove subviews until after the animation, or they'll
        // swoop in from origo during the animation.
        
        scroll_animating = YES;
        [UIView beginAnimations: @"MuScroll" context: NULL];
        [UIView setAnimationDuration: 0.4];
        [UIView setAnimationBeginsFromCurrentState: YES];
        [UIView setAnimationDelegate: self];
        [UIView setAnimationDidStopSelector: @selector(onGotoPageFinished)];
        
        for (UIView<MuPageView> *view in canvasScrollView.subviews)
            [view resetZoomAnimated: NO];
        
        canvasScrollView.contentOffset = CGPointMake(number * width, 0);
        //slider.value = number;
        //indicator.text = [NSString stringWithFormat: @" %d of %d ", number+1, fz_count_pages(ctx, doc)];
        
        [UIView commitAnimations];
    } else {
        for (UIView<MuPageView> *view in canvasScrollView.subviews)
            [view resetZoomAnimated: NO];
        canvasScrollView.contentOffset = CGPointMake(number * width, 0);
    }
    current = number;
}


- (void) onGotoPageFinished
{
    scroll_animating = NO;
    [self scrollViewDidScroll: canvasScrollView];
}


- (void) resetSearch
{
    searchPage = -1;
    for (UIView<MuPageView> *view in canvasScrollView
         .subviews)
        [view clearSearchResults];
}
- (void) scrollViewDidScroll: (UIScrollView*)scrollview
{
    // scrollViewDidScroll seems to get called part way through a screen rotation.
    // (This is possibly a UIScrollView bug - see
    // http://stackoverflow.com/questions/4123991/uiscrollview-disable-scrolling-while-rotating-on-iphone-ipad/8141423#8141423 ).
    // This ends up corrupting the current page number, because the calculation
    // 'current = x / width' is using the new value of 'width' before the
    // pages have been resized/repositioned. To avoid this problem, we filter out
    // calls to scrollViewDidScroll during rotation.
    if (_isRotating)
        return;
    
    if (width == 0)
        return; // not visible yet
    
    if (scroll_animating)
        return; // don't mess with layout during animations
    
    float x = canvasScrollView.contentOffset.x + width * 0.5f;
    current = x / width;
    
    //[[NSUserDefaults standardUserDefaults] setInteger: current forKey: key];
    
    //indicator.text = [NSString stringWithFormat: @" %d of %d ", current+1, fz_count_pages(ctx, doc)];
    //slider.value = current;
    
    // swap the distant page views out
    
    NSMutableSet *invisiblePages = [[NSMutableSet alloc] init];
    for (UIView<MuPageView> *view in canvasScrollView.subviews) {
        if (view.number != current)
            [view resetZoomAnimated: YES];
        if (view.number < current - 2 || view.number > current + 2)
            [invisiblePages addObject: view];
    }
    for (UIView<MuPageView> *view in invisiblePages)
        [view removeFromSuperview];
    //[invisiblePages release]; // don't bother recycling them...
    
    [self createPageView: current];
    [self createPageView: current - 1];
    [self createPageView: current + 1];
    
    // reset search results when page has flipped
    if (current != searchPage)
        [self resetSearch];
}


- (void) createPageView: (int)number
{
    
    if (number < 0 || number >= fz_count_pages(ctx, doc))
        return;
    int found = 0;
    for (UIView<MuPageView> *view in canvasScrollView.subviews)
        if (view.number == number)
            found = 1;
    if (!found) {
        UIView<MuPageView> *view
        = reflowMode
        ? [[MuPageViewReflow alloc] initWithFrame:CGRectMake(number * width, 0, width-GAP, height) document:docRef page:number]
        : [[MuPageViewNormal alloc] initWithFrame:CGRectMake(number * width, 0, width-GAP, height) dialogCreator:self updater:self document:docRef page:number];
        [view setScale:scale];
        [canvasScrollView addSubview: view];
        if (showLinks)
            [view showLinks];
        //[view release];
    }
    
    
    //    if (number < 0 || number >= fz_count_pages(ctx, doc))
    //        return;
    //    int found = 0;
    //    for (UIView<MuPageView> *view in _canvasScrollView.subviews)
    //        if (view.number == number)
    //            found = 1;
    //    if (!found) {
    //        UIView<MuPageView> *view
    //        = reflowMode
    //        ? [[MuPageViewReflow alloc] initWithFrame:CGRectMake(0, (number * height), width, height+GAP) document:docRef page:number]
    //        : [[MuPageViewNormal alloc] initWithFrame:CGRectMake(0, (number * height), width, height+GAP) dialogCreator:self updater:self document:docRef page:number];
    //        [view setScale:scale];
    //        [_canvasScrollView addSubview: view];
    //        if (showLinks)
    //            [view showLinks];
    //        //[view release];
    //    }
}


- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
//    /********************************Inactive***************************************/
//    
//    if (alertView.tag == 13)
//    {
//        if (buttonIndex == 0)
//        {
//            
//            
//            [self startActivity:@"Processing..."];
//            NSString *requestURL = [NSString stringWithFormat:@"%@MarkAsInactive?documentId=%@&Status=%@",kInactive,_workflowID,@"Draft"];
//            
//            [WebserviceManager sendSyncRequestWithURLGet:requestURL method:SAServiceReqestHTTPMethodGET body:requestURL completionBlock:^(BOOL status, id responseValue) {
//                
//                if(status)
//                {
//                    dispatch_async(dispatch_get_main_queue(),
//                                   ^{
//                                       
//                                       
//                                       _inactiveArray =responseValue;
//                                       if (_inactiveArray != (id)[NSNull null])
//                                       {
//                                           [self.navigationController popViewControllerAnimated:YES];
//                                           //alertView.delegate = self;
//                                           //
//                                           [self stopActivity];
//                                       }
//                                       else{
//                                           return ;
//                                       }
//                                       
//                                       /*******************/
//                                       
//                                       
//                                       
//                                                                    
//                                       
//                                   });  
//                      
//                }
//                else{
//                    
//                    
//                }
//                
//            }];
//            
//            
//            
//        }
//        else if (buttonIndex == 0)
//        {
//            
//        }
//    }
//    
//    
//    else if (alertView.tag == 14)
//    {
//        if (buttonIndex == 0)
//        {
//            
//            [self startActivity:@"Loading..."];
//            
//            NSString *requestURL = [NSString stringWithFormat:@"%@GetDraftFileData?workFlowId=%@",kDraftPDFImage,_workflowID];
//            [WebserviceManager sendSyncRequestWithURLGet:requestURL method:SAServiceReqestHTTPMethodGET body:requestURL completionBlock:^(BOOL status, id responseValue) {
//                
//                
//                
//                if(status)
//                {
//                    dispatch_async(dispatch_get_main_queue(), ^{
//                        
//                        _pdfImageArray=[[responseValue valueForKey:@"Response"] valueForKey:@"FileData"];
//                        int Count;
//                        NSData *data = [[NSData alloc]initWithBase64EncodedString:[[responseValue valueForKey:@"Response"] valueForKey:@"FileData"] options:0];
//                        NSString *documentsDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
//                        NSString *path = [documentsDirectory stringByAppendingPathComponent:[_myTitle stringByAppendingPathExtension:@"pdf"]];
//                        NSArray *directoryContent = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:NULL];
//                        for (Count = 0; Count < (int)[directoryContent count]; Count++)
//                        {
//                            NSLog(@"File %d: %@", (Count + 1), [directoryContent objectAtIndex:Count]);
//                        }
//                        [data writeToFile:path atomically:YES];
//                        [self stopActivity];
//                        UIAlertView *alertView28 = [[UIAlertView alloc] initWithTitle:@"View"
//                                                                              message:@"Do you want to view document?"
//                                                                             delegate:self
//                                                                    cancelButtonTitle:@"Ok"
//                                                                    otherButtonTitles:@"Cancel", nil];
//                        alertView28.tag = 28;
//                        [alertView28 show];
//                        
//                        
//                    });
//                    
//                }
//                else{
//                    
//                    
//                }
//                
//            }];
//            
//            
//        }
//        else if (buttonIndex == 0)
//        {
//            
//        }
//    }
//    /****************************Open Downloaded file*******************************/
//    else if (alertView.tag == 28)
//    {
//        if (buttonIndex == 0)
//        {
//            //currentPreviewIndex=[(UIButton *)sender tag]-1;
//            
//            QLPreviewController *previewController=[[QLPreviewController alloc]init];
//            previewController.delegate=self;
//            previewController.dataSource=self;
//            [self presentViewController:previewController animated:YES completion:nil];
//            [previewController.navigationItem setRightBarButtonItem:nil];
//        }
//        
//    }
}
#pragma mark - data source(Preview)
//Data source methods
//– numberOfPreviewItemsInPreviewController:
//– previewController:previewItemAtIndex:
- (NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller
{
    //return [filenamesArray count];
    
    
    return 1;
}

- (id <QLPreviewItem>)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index
{
    NSString *path = [[[[NSFileManager defaultManager] URLsForDirectory:NSCachesDirectory inDomains:NSUserDomainMask] lastObject] path];
    //You'll need an additional '/'
    NSString *fullPath = [path stringByAppendingFormat:@"/%@", [_myTitle  stringByAppendingPathExtension:@"pdf"]];
    return [NSURL fileURLWithPath:fullPath];
}

#pragma mark - delegate methods


- (BOOL)previewController:(QLPreviewController *)controller shouldOpenURL:(NSURL *)url forPreviewItem:(id <QLPreviewItem>)item
{
    return YES;
}

- (CGRect)previewController:(QLPreviewController *)controller frameForPreviewItem:(id <QLPreviewItem>)item inSourceView:(UIView **)view
{
    
    //Rectangle of the button which has been pressed by the user
    //Zoom in and out effect appears to happen from the button which is pressed.
    UIView *view1 = [self.view viewWithTag:currentPreviewIndex+1];
    return view1.frame;
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}
- (IBAction)inactiveBtn:(id)sender
{
//    UIAlertView *alertView13 = [[UIAlertView alloc] initWithTitle:@"Inactive"
//                                                         message:@"Do you really want to mark as inactive?"
//                                                        delegate:self
//
//                                               cancelButtonTitle:@"Yes"
//                                               otherButtonTitles:@"No", nil];
//    alertView13.delegate = self;
//    alertView13.tag = 13;
//    [alertView13 show];
    
    UIAlertController * alert = [UIAlertController
                                 alertControllerWithTitle:@""
                                 message:@"Do you want to mark document as inactive?"
                                 preferredStyle:UIAlertControllerStyleAlert];
    
    //Add Buttons
    
    UIAlertAction* yesButton = [UIAlertAction
                                actionWithTitle:@"Yes"
                                style:UIAlertActionStyleDefault
                                handler:^(UIAlertAction * action) {
                                    //Handle your yes please button action here
                                    [self startActivity:@"Processing..."];
                                    NSString *requestURL = [NSString stringWithFormat:@"%@MarkAsInactive?documentId=%@&Status=%@",kInactive,_workflowID,@"Draft"];
                                    
                                    [WebserviceManager sendSyncRequestWithURLGet:requestURL method:SAServiceReqestHTTPMethodGET body:requestURL completionBlock:^(BOOL status, id responseValue) {
                                        
                                        if(status)
                                        {
                                            dispatch_async(dispatch_get_main_queue(),
                                                           ^{
                                                               
                                                               
                                                               _inactiveArray =responseValue;
                                                               if (_inactiveArray != (id)[NSNull null])
                                                               {
                                                                   
                                                                   
                                                                   
                                                           [self.navigationController popToRootViewControllerAnimated:YES];
                                                                   //alertView.delegate = self;
                                                                   //
                                                                   [self stopActivity];
                                                               }
                                                               else{
                                                                   return ;
                                                               }
                                                               
                                                               /*******************/
                                                               
                                                               
                                                               
                                                               
                                                               
                                                           });
                                            
                                        }
                                        else{
                                            
                                            
                                        }
                                        
                                    }];
                                    
                                }];
    
    UIAlertAction* noButton = [UIAlertAction
                               actionWithTitle:@"No"
                               style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction * action) {
                                   //Handle no, thanks button
                               }];
    
    //Add your buttons to alert controller
    
    [alert addAction:yesButton];
    [alert addAction:noButton];
    
    [self presentViewController:alert animated:YES completion:nil];
    
}

- (IBAction)downloadBtn:(id)sender
{
    
    UIAlertController * alert = [UIAlertController
                                 alertControllerWithTitle:@""
                                 message:@"Do you want to download document?"
                                 preferredStyle:UIAlertControllerStyleAlert];
    
    //Add Buttons
    
    UIAlertAction* yesButton = [UIAlertAction
                                actionWithTitle:@"Yes"
                                style:UIAlertActionStyleDefault
                                handler:^(UIAlertAction * action) {
                                    //Handle your yes please button action here
                                    
                                    [self startActivity:@"Loading..."];
                                    
                                    NSString *requestURL = [NSString stringWithFormat:@"%@GetDraftFileData?workFlowId=%@",kDraftPDFImage,_workflowID];
                                    [WebserviceManager sendSyncRequestWithURLGet:requestURL method:SAServiceReqestHTTPMethodGET body:requestURL completionBlock:^(BOOL status, id responseValue) {
                                        
                                        
                                        
                                        if(status)
                                        {
                                            dispatch_async(dispatch_get_main_queue(), ^{
                                                
                                                _pdfImageArray=[[responseValue valueForKey:@"Response"] valueForKey:@"FileData"];
                                                int Count;
                                                NSData *data = [[NSData alloc]initWithBase64EncodedString:[[responseValue valueForKey:@"Response"] valueForKey:@"FileData"] options:0];
                                                NSString *documentsDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
                                                NSString *path = [documentsDirectory stringByAppendingPathComponent:[_myTitle stringByAppendingPathExtension:@"pdf"]];
                                                NSArray *directoryContent = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:NULL];
                                                for (Count = 0; Count < (int)[directoryContent count]; Count++)
                                                {
                                                    NSLog(@"File %d: %@", (Count + 1), [directoryContent objectAtIndex:Count]);
                                                }
                                                [data writeToFile:path atomically:YES];
                                                [self stopActivity];
                                                
                                                UIAlertController * alert = [UIAlertController
                                                                             alertControllerWithTitle:@"View"
                                                                             message:@"Do you want to view document?"
                                                                             preferredStyle:UIAlertControllerStyleAlert];
                                                
                                                //Add Buttons
                                                
                                                UIAlertAction* yesButton = [UIAlertAction
                                                                            actionWithTitle:@"Ok"
                                                                            style:UIAlertActionStyleDefault
                                                                            handler:^(UIAlertAction * action) {
                                                                                //Handle your yes please button action here
                                                                                QLPreviewController *previewController=[[QLPreviewController alloc]init];
                                                                                previewController.delegate=self;
                                                                                previewController.dataSource=self;
                                                                                [self presentViewController:previewController animated:YES completion:nil];
                                                                                [previewController.navigationItem setRightBarButtonItem:nil];
                                                                            }];
                                                
                                                UIAlertAction* noButton = [UIAlertAction
                                                                           actionWithTitle:@"Cancel"
                                                                           style:UIAlertActionStyleDefault
                                                                           handler:^(UIAlertAction * action) {
                                                                               //Handle no, thanks button
                                                                           }];
                                                
                                                //Add your buttons to alert controller
                                                
                                                [alert addAction:yesButton];
                                                [alert addAction:noButton];
                                                
                                                [self presentViewController:alert animated:YES completion:nil];

//                                                UIAlertView *alertView28 = [[UIAlertView alloc] initWithTitle:@"View"
//                                                                                                      message:@"Do you want to view document?"
//                                                                                                     delegate:self
//                                                                                            cancelButtonTitle:@"Ok"
//                                                                                            otherButtonTitles:@"Cancel", nil];
//                                                alertView28.tag = 28;
//                                                [alertView28 show];
                                                
                                                
                                            });
                                            
                                        }
                                        else{
                                            
                                            
                                        }
                                        
                                    }];
                                    
                                }];
    
    UIAlertAction* noButton = [UIAlertAction
                               actionWithTitle:@"No"
                               style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction * action) {
                                   //Handle no, thanks button
                               }];
    
    //Add your buttons to alert controller
    
    [alert addAction:yesButton];
    [alert addAction:noButton];
    
    [self presentViewController:alert animated:YES completion:nil];
    
}

- (IBAction)shareBtn:(id)sender {
    UIStoryboard *newStoryBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    ShareVC *objTrackOrderVC= [newStoryBoard instantiateViewControllerWithIdentifier:@"ShareVC"];
    
    self.definesPresentationContext = YES; //self is presenting view controller
    //objTrackOrderVC.view.backgroundColor = [UIColor clearColor];
    objTrackOrderVC.modalPresentationStyle = UIModalPresentationOverCurrentContext;
    objTrackOrderVC.documentName = _myTitle;
    objTrackOrderVC.documentID = _workflowID;
    //objTrackOrderVC.strExcutedFrom=@"WaitingForOther";
    [self.navigationController pushViewController:objTrackOrderVC animated:YES];

    //[self.navigationController presentViewController:objTrackOrderVC animated:YES completion:nil];

}
/*
#pragma mark - Navigation

// In a storyboard-based application, you will often want to do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    // Get the new view controller using [segue destinationViewController].
    // Pass the selected object to the new view controller.
}
*/


@end
